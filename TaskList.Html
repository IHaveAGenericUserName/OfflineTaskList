<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Tasklist</title>
    
    <script src="./dependencies/react.js"></script>
    <script src="./dependencies/react-dom.js"></script>
    <script src="./dependencies/babel.js"></script>

    <style>
        :root {
            /* Palette */
            --primary: #6366f1;
            --primary-hover: #4f46e5;
            --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --surface: #ffffff;
            --text-main: #1f2937;
            --text-muted: #6b7280;
            --border-light: #f3f4f6;
            --danger: #ef4444;
            
            /* Spacing & Radius */
            --radius-md: 12px;
            --radius-sm: 8px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-main);
            min-height: 100vh;
            margin: 0;
            padding: 40px 20px;
            box-sizing: border-box;
        }

        .app-wrapper { max-width: 850px; margin: 0 auto; }
        
        h1 { 
            text-align: center; 
            color: var(--text-main); 
            font-weight: 800; 
            letter-spacing: -0.5px;
            margin-bottom: 30px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* --- CONTROLS BAR --- */
        .status-bar {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: var(--radius-md);
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-sm);
            border: 1px solid rgba(255,255,255,0.5);
        }

        .status-indicator { display: flex; align-items: center; gap: 8px; font-weight: 500; font-size: 0.9rem; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        .dot.green { background: #10b981; box-shadow: 0 0 0 3px #d1fae5; }
        .dot.orange { background: #f59e0b; box-shadow: 0 0 0 3px #fef3c7; }
        .dot.grey { background: #9ca3af; }

        /* --- BUTTONS --- */
        button {
            border: none;
            background: white;
            padding: 8px 14px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-main);
            display: flex; align-items: center; gap: 6px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        button:hover { background: #f9fafb; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        
        button.primary { background: var(--primary); color: white; }
        button.primary:hover { background: var(--primary-hover); box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3); }
        
        button.icon-btn { 
            padding: 6px; background: transparent; box-shadow: none; color: #9ca3af; 
        }
        button.icon-btn:hover { background: rgba(0,0,0,0.05); color: var(--primary); transform: none; }
        button.icon-btn.danger:hover { color: var(--danger); background: #fef2f2; }
        
        button.priority-btn { color: #d1d5db; }
        button.priority-btn.active { color: #f59e0b; }
        button.priority-btn:hover { color: #f59e0b; transform: scale(1.1); }

        svg { width: 1.2em; height: 1.2em; fill: currentColor; }

        /* --- SECTIONS --- */
        .section {
            background: var(--surface);
            border-radius: var(--radius-md);
            margin-bottom: 24px;
            box-shadow: var(--shadow-md);
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.02);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .section.dragging-section { opacity: 0.4; transform: scale(0.98); box-shadow: var(--shadow-lg); }

        .section-header {
            display: flex; align-items: center; 
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid var(--border-light);
        }

        .section-drag-handle {
            cursor: grab; color: #d1d5db; margin-right: 8px; padding: 4px; border-radius: 4px;
        }
        .section-drag-handle:hover { background: #f3f4f6; color: var(--text-main); }
        .section-drag-handle:active { cursor: grabbing; }

        .section-title-input {
            flex-grow: 1; font-weight: 700; font-size: 1.05rem; 
            border: 1px solid transparent; background: transparent; 
            padding: 4px 8px; margin: 0 4px; border-radius: 4px; color: var(--text-main);
        }
        .section-title-input:focus { outline: none; background: #f9fafb; border-color: #e5e7eb; }

        /* --- TASKS --- */
        .task-list { list-style: none; padding: 0; margin: 0; min-height: 40px; }
        
        .task-item {
            display: flex; align-items: center; 
            padding: 12px 20px;
            background: white;
            border-bottom: 1px solid var(--border-light);
            transition: background 0.1s;
        }
        .task-item:last-child { border-bottom: none; }
        .task-item:hover { background: #f9fafb; }
        .task-item.high-priority { background: #fffbf0; border-left: 3px solid #f59e0b; }

        .task-drag-handle { cursor: grab; color: #e5e7eb; margin-right: 12px; display: flex; padding: 4px;}
        .task-item:hover .task-drag-handle { color: #9ca3af; }
        .task-drag-handle:active { cursor: grabbing; }

        .task-text { flex-grow: 1; margin: 0 12px; font-size: 0.95rem; line-height: 1.5; }
        .completed { text-decoration: line-through; color: #9ca3af; }

        /* --- INPUT --- */
        .add-task-row { padding: 16px 20px; border-top: 1px solid var(--border-light); background: #fafafa; }
        .add-task-row input { 
            width: 100%; border: 1px solid #e5e7eb; border-radius: var(--radius-sm); 
            padding: 10px 14px; font-size: 0.95rem; box-shadow: var(--shadow-sm); outline: none; 
            transition: all 0.2s; box-sizing: border-box;
        }
        .add-task-row input:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1); }

        /* --- DROP INDICATORS --- */
        .drop-target-top { border-top: 2px solid var(--primary) !important; }
        .drop-target-bottom { border-bottom: 2px solid var(--primary) !important; }
        
        /* When dragging a Task over a Section (appending) */
        .section-task-drop-target { border: 2px dashed var(--primary); background: #eef2ff; }

    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- ICONS (SVG) ---
    const Icons = {
        Plus: () => <svg viewBox="0 0 256 256"><path d="M224,128a8,8,0,0,1-8,8H136v80a8,8,0,0,1-16,0V136H40a8,8,0,0,1,0-16h80V40a8,8,0,0,1,16,0v80h80A8,8,0,0,1,224,128Z"/></svg>,
        Trash: () => <svg viewBox="0 0 256 256"><path d="M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM96,40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8v8H96Zm96,168H64V64H192ZM112,104v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Z"/></svg>,
        CaretRight: () => <svg viewBox="0 0 256 256"><path d="M181.66,133.66l-80,80A8,8,0,0,1,88,208V48a8,8,0,0,1,13.66-5.66l80,80A8,8,0,0,1,181.66,133.66Z"/></svg>,
        CaretDown: () => <svg viewBox="0 0 256 256"><path d="M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,48,88H208a8,8,0,0,1,5.66,13.66Z"/></svg>,
        X: () => <svg viewBox="0 0 256 256"><path d="M205.66,194.34a8,8,0,0,1-11.32,11.32L128,139.31,61.66,205.66a8,8,0,0,1-11.32-11.32L116.69,128,50.34,61.66A8,8,0,0,1,61.66,50.34L128,116.69l66.34-66.35a8,8,0,0,1,11.32,11.32L139.31,128Z"/></svg>,
        Dots: () => <svg viewBox="0 0 256 256"><path d="M92,60a12,12,0,1,1-12-12A12,12,0,0,1,92,60Zm0,68a12,12,0,1,1-12-12A12,12,0,0,1,92,128Zm0,68a12,12,0,1,1-12-12A12,12,0,0,1,92,196Qm164,48a12,12,0,1,0,12,12A12,12,0,0,0,164,48Zm0,68a12,12,0,1,0,12,12A12,12,0,0,0,164,116Zm0,68a12,12,0,1,0,12,12A12,12,0,0,0,164,184Z"/></svg>,
        Grip: () => <svg viewBox="0 0 256 256"><path d="M100,64a12,12,0,1,1-12-12A12,12,0,0,1,100,64Zm56-12a12,12,0,1,0,12,12A12,12,0,0,0,156,52ZM88,116a12,12,0,1,0,12,12A12,12,0,0,0,88,116Zm68,0a12,12,0,1,0,12,12A12,12,0,0,0,156,116ZM88,180a12,12,0,1,0,12,12A12,12,0,0,0,88,180Zm68,0a12,12,0,1,0,12,12A12,12,0,0,0,156,180Z"/></svg>,
        Link: () => <svg viewBox="0 0 256 256"><path d="M136.37,180.24a48,48,0,0,1-67.88-67.88l18.34-18.35a8,8,0,0,1,11.32,11.32L79.8,123.68a32,32,0,1,0,45.25,45.25l18.35-18.34a8,8,0,0,1,11.32,11.32ZM201.14,54.86a48,48,0,0,0-67.88,0L114.91,73.2a8,8,0,0,0,11.32,11.31l18.35-18.34a32,32,0,0,1,45.25,45.25l-18.34,18.35a8,8,0,0,0,11.32,11.32l18.34-18.35A48,48,0,0,0,201.14,54.86Z"/></svg>,
        Upload: () => <svg viewBox="0 0 256 256"><path d="M224,144v64a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V144a8,8,0,0,1,16,0v56H208V144a8,8,0,0,1,16,0Zm-101.66-85.66a8,8,0,0,0-11.32,0l-40,40a8,8,0,0,0,11.32,11.32L120,72.31V152a8,8,0,0,0,16,0V72.31l37.66,37.35a8,8,0,0,0,11.32-11.32Z"/></svg>,
        Connect: () => <svg viewBox="0 0 256 256"><path d="M227.32,76.69l-48-48a8,8,0,0,0-11.32,0l-6.62,6.62L134.06,8.06a8,8,0,0,0-11.31,0l-16,16a8,8,0,0,0,0,11.31L128,56.69,114.34,70.34,50.34,6.34A8,8,0,0,0,39,17.66l44.69,44.68L17.66,128.34a8,8,0,0,0,0,11.32l48,48a8,8,0,0,0,11.32,0L142.94,121.7l64,64a8,8,0,0,0,11.31,0l16-16a8,8,0,0,0,0-11.31l-27.26-27.26,21.37-21.37A8,8,0,0,0,227.32,76.69Zm-156,104-36.68-36.68L84,94.63l36.69,36.68Zm120-40L154.63,104l36.68-36.69,36.69,36.69Z"/></svg>,
        Bolt: () => <svg viewBox="0 0 256 256"><path d="M160,16a8,8,0,0,0-7.22,4.59l-47.53,99H48a8,8,0,0,0-7.22,11.41l56,112a8,8,0,0,0,14.44-7.22L97.58,160H160a8,8,0,0,0,7.22-11.41l-40-80h40a8,8,0,0,0,7.22-11.41l-16-32A8,8,0,0,0,160,16Zm-24.89,128H96a8,8,0,0,0-7.22,11.41l13.11,26.21L56.45,136H104a8,8,0,0,0,7.22-11.41l-13.11-26.21L143.55,80H96a8,8,0,0,0-7.22,11.41l13.11,26.21L64.45,152H112a8,8,0,0,0,7.22-11.41l-13.11-26.21L151.55,96H120Z" style={{fillRule:'nonzero'}}/></svg>,
        BoltFill: () => <svg viewBox="0 0 256 256"><path d="M215.22,92.59l-16-32A8,8,0,0,0,192,56H152l40-80a8,8,0,0,0-14.44-7.22l-128,240a8,8,0,0,0,14.44,7.22L96,160h64a8,8,0,0,0,7.22-11.41l-40-80H160A8,8,0,0,0,215.22,92.59Z"/></svg>
    };

    // --- DB HELPERS ---
    const DB_NAME = 'TaskAppDB';
    const STORE_NAME = 'handles';
    const getFileHandle = async () => {
        return new Promise((resolve) => {
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = (e) => e.target.result.createObjectStore(STORE_NAME);
            request.onsuccess = (e) => {
                const tx = e.target.result.transaction(STORE_NAME, 'readonly');
                const req = tx.objectStore(STORE_NAME).get('tasksFile');
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            };
            request.onerror = () => resolve(null);
        });
    };
    const saveFileHandle = async (handle) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onsuccess = (e) => {
            const tx = e.target.result.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(handle, 'tasksFile');
        };
    };

    function App() {
        const [sections, setSections] = useState([]);
        const [fileHandle, setFileHandle] = useState(null);
        const [isVerified, setIsVerified] = useState(false);
        const [isSaving, setIsSaving] = useState(false);
        
        // DnD State
        const [draggedItem, setDraggedItem] = useState(null); 
        const [dropTarget, setDropTarget] = useState(null);

        // --- Init ---
        useEffect(() => {
            const savedData = localStorage.getItem('myDailyTasks');
            if (savedData) setSections(JSON.parse(savedData));
            else setSections([{ id: 'default', title: 'To Do', collapsed: false, tasks: [] }]);
            checkForExistingHandle();
        }, []);

        const checkForExistingHandle = async () => {
            const handle = await getFileHandle();
            if (handle) { setFileHandle(handle); setIsVerified(false); }
        };

        useEffect(() => { localStorage.setItem('myDailyTasks', JSON.stringify(sections)); }, [sections]);

        useEffect(() => {
            if (!fileHandle || !isVerified) return;
            const saveData = async () => {
                setIsSaving(true);
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(generateMD(sections));
                    await writable.close();
                } catch (err) {
                    if (err.name === 'NotAllowedError') setIsVerified(false);
                } finally { setIsSaving(false); }
            };
            const debounce = setTimeout(saveData, 1000);
            return () => clearTimeout(debounce);
        }, [sections, fileHandle, isVerified]);

        const generateMD = (data) => {
            let content = "";
            data.forEach(sec => {
                content += `## ${sec.title}\n`;
                sec.tasks.forEach(t => {
                    const priorityMark = t.priority ? " (!)" : "";
                    content += `- [${t.completed ? 'x' : ' '}] ${t.text}${priorityMark}\n`;
                });
                content += `\n`;
            });
            return content;
        };

        const connectFile = async (forceNew = false) => {
            try {
                if (!forceNew && fileHandle) {
                    const permission = await fileHandle.requestPermission({ mode: 'readwrite' });
                    if (permission === 'granted') {
                         setIsVerified(true);
                         const writable = await fileHandle.createWritable();
                         await writable.write(generateMD(sections));
                         await writable.close();
                         return;
                    }
                }
                const handle = await window.showSaveFilePicker({
                    suggestedName: 'tasks.md',
                    types: [{ description: 'Markdown', accept: {'text/markdown': ['.md']} }],
                });
                setFileHandle(handle);
                saveFileHandle(handle);
                setIsVerified(true);
            } catch (err) { console.log("Cancelled"); }
        };

        const loadFromFile = async () => {
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [{ description: 'Markdown', accept: {'text/markdown': ['.md']} }],
                });
                const file = await handle.getFile();
                const text = await file.text();
                
                const lines = text.split('\n');
                const newSections = [];
                let currentSec = { id: Date.now(), title: "Imported", collapsed: false, tasks: [] };
                
                lines.forEach((line, i) => {
                    const trim = line.trim();
                    if (trim.startsWith('##')) {
                        if (currentSec.tasks.length || currentSec.title !== "Imported") newSections.push(currentSec);
                        currentSec = { id: Date.now()+i, title: trim.replace(/^##\s+/, ''), collapsed: false, tasks: [] };
                    } else if (trim.startsWith('- [')) {
                        const isHigh = line.includes('(!)');
                        const cleanText = trim.replace(/- \[[x ]\]\s/, '').replace('(!)', '').trim();
                        currentSec.tasks.push({ 
                            id: Date.now()+i, 
                            text: cleanText, 
                            completed: trim.includes('- [x]'),
                            priority: isHigh 
                        });
                    }
                });
                newSections.push(currentSec);
                
                setSections(newSections);
                setFileHandle(handle);
                saveFileHandle(handle);
                const perm = await handle.requestPermission({ mode: 'readwrite' });
                if(perm === 'granted') setIsVerified(true);
            } catch (err) { console.error(err); }
        };

        // --- CRUD Logic ---
        const addTask = (secIdx, text) => {
            if(!text.trim()) return;
            const newS = [...sections];
            newS[secIdx].tasks.push({ id: Date.now(), text, completed: false, priority: false });
            setSections(newS);
        };
        const toggleTask = (secIdx, tIdx) => {
            const newS = [...sections]; newS[secIdx].tasks[tIdx].completed = !newS[secIdx].tasks[tIdx].completed; setSections(newS);
        };
        const togglePriority = (secIdx, tIdx) => {
            const newS = [...sections]; newS[secIdx].tasks[tIdx].priority = !newS[secIdx].tasks[tIdx].priority; setSections(newS);
        };
        const deleteItem = (secIdx, tIdx) => {
            const newS = [...sections]; newS[secIdx].tasks.splice(tIdx, 1); setSections(newS);
        };
        const deleteSection = (idx) => {
            if(confirm("Delete entire section?")) { const newS=[...sections]; newS.splice(idx,1); setSections(newS); }
        };

        // --- Drag & Drop Core ---
        const handleDragStart = (e, type, payload) => {
            e.stopPropagation(); // Prevent Drag start bubbling
            setDraggedItem({ type, ...payload });
            
            setTimeout(() => {
                const target = type === 'SECTION' 
                    ? e.target 
                    : e.target.closest('.task-item');
                if(target) target.classList.add(type === 'SECTION' ? 'dragging-section' : 'dragging');
            }, 0);
        };

        const handleDragEnd = () => {
            document.querySelectorAll('.dragging, .dragging-section').forEach(el => el.classList.remove('dragging', 'dragging-section'));
            setDraggedItem(null);
            setDropTarget(null);
        };

        const handleDragOver = (e, type, payload) => {
            e.preventDefault(); 
            e.stopPropagation(); // CRITICAL: Stop section from capturing task hovers

            if (!draggedItem) return;

            // 1. Reordering Sections
            if (draggedItem.type === 'SECTION' && type === 'SECTION') {
                const rect = e.currentTarget.getBoundingClientRect();
                const midpoint = (rect.bottom - rect.top) / 2;
                const position = (e.clientY - rect.top) < midpoint ? 'top' : 'bottom';
                
                setDropTarget(prev => {
                    if(prev?.type === 'SECTION' && prev.secIndex === payload.secIndex && prev.position === position) return prev;
                    return { type: 'SECTION', secIndex: payload.secIndex, position };
                });
            }

            // 2. Reordering Tasks (Dragging Task over Task)
            else if (draggedItem.type === 'TASK' && type === 'TASK') {
                 // Prevent dragging across sections if you prefer, but here we allow it
                const rect = e.currentTarget.getBoundingClientRect();
                const midpoint = (rect.bottom - rect.top) / 2;
                const position = (e.clientY - rect.top) < midpoint ? 'top' : 'bottom';

                setDropTarget(prev => {
                    if(prev?.type === 'TASK' && prev.secIndex === payload.secIndex && prev.taskIndex === payload.taskIndex && prev.position === position) return prev;
                    return { type: 'TASK', secIndex: payload.secIndex, taskIndex: payload.taskIndex, position };
                });
            }

            // 3. Dragging Task over Section Container (Append to Section)
            else if (draggedItem.type === 'TASK' && type === 'SECTION') {
                setDropTarget(prev => {
                    // secIndex is target, taskIndex -1 means "append to end"
                    if(prev?.type === 'TASK' && prev.secIndex === payload.secIndex && prev.taskIndex === -1) return prev;
                    return { type: 'TASK', secIndex: payload.secIndex, taskIndex: -1, position: 'bottom' };
                });
            }
        };

        const handleDrop = (e) => {
            e.preventDefault();
            e.stopPropagation(); // Stop bubbling
            
            if (!draggedItem || !dropTarget) return;

            // Handle Section Move
            if (draggedItem.type === 'SECTION' && dropTarget.type === 'SECTION') {
                const newS = [...sections];
                const [movedSec] = newS.splice(draggedItem.secIndex, 1);
                let targetIdx = dropTarget.secIndex;
                if (dropTarget.position === 'bottom') targetIdx++;
                if (draggedItem.secIndex < targetIdx) targetIdx--;
                newS.splice(targetIdx, 0, movedSec);
                setSections(newS);
            }
            
            // Handle Task Move
            else if (draggedItem.type === 'TASK' && dropTarget.type === 'TASK') {
                const newS = [...sections];
                const { sourceSecIndex, itemIndex } = draggedItem;
                
                // Remove from source
                const [movedItem] = newS[sourceSecIndex].tasks.splice(itemIndex, 1);
                
                // Add to target
                let targetIdx = dropTarget.taskIndex;
                if(dropTarget.taskIndex === -1) {
                    // Appending to section
                    newS[dropTarget.secIndex].tasks.push(movedItem);
                } else {
                    if (dropTarget.position === 'bottom') targetIdx++;
                    // Correction for same-list drop
                    if (sourceSecIndex === dropTarget.secIndex && itemIndex < targetIdx) targetIdx--; 
                    newS[dropTarget.secIndex].tasks.splice(targetIdx, 0, movedItem);
                }
                setSections(newS);
            }
            
            handleDragEnd();
        };

        return (
            <div className="app-wrapper">
                <h1>Offline Tasklist</h1>
                
                <div className="status-bar">
                    {!fileHandle ? (
                        <>
                            <div className="status-indicator"><span className="dot grey"></span><span style={{color: '#6b7280'}}>Local Only</span></div>
                            <div style={{display:'flex', gap:'10px'}}>
                                <button onClick={loadFromFile}><Icons.Upload /> Open</button>
                                <button onClick={() => connectFile(true)} className="primary"><Icons.Link /> Connect File</button>
                            </div>
                        </>
                    ) : !isVerified ? (
                        <>
                            <div className="status-indicator"><span className="dot orange"></span><span style={{color: '#f59e0b'}}>{fileHandle.name} (Paused)</span></div>
                            <div style={{display:'flex', gap:'10px'}}>
                                <button onClick={() => connectFile(false)} className="primary"><Icons.Connect /> Reconnect</button>
                                <button onClick={() => connectFile(true)}>Switch</button>
                            </div>
                        </>
                    ) : (
                        <>
                            <div className="status-indicator"><span className="dot green"></span><span style={{color: '#10b981'}}>{fileHandle.name} {isSaving ? '(Saving...)' : '(Active)'}</span></div>
                            <button onClick={() => connectFile(true)}>Switch</button>
                        </>
                    )}
                </div>

                {sections.map((section, sIdx) => {
                    // Visual logic for Section Drops
                    let secStyle = {};
                    let dropClass = '';
                    
                    // Case A: Dropping a Section Reorder
                    if(dropTarget && dropTarget.type === 'SECTION' && dropTarget.secIndex === sIdx) {
                         secStyle = dropTarget.position === 'top' ? { borderTop: '3px solid var(--primary)' } : { borderBottom: '3px solid var(--primary)' };
                    }
                    
                    // Case B: Dragging a Task over a Section (Append mode)
                    if(dropTarget && dropTarget.type === 'TASK' && dropTarget.secIndex === sIdx && dropTarget.taskIndex === -1) {
                        dropClass = 'section-task-drop-target';
                    }

                    return (
                        <div 
                            key={section.id} 
                            className={`section ${dropClass}`}
                            style={secStyle}
                            draggable
                            onDragStart={(e) => handleDragStart(e, 'SECTION', { secIndex: sIdx })}
                            onDragOver={(e) => handleDragOver(e, 'SECTION', { secIndex: sIdx })}
                            onDrop={handleDrop}
                            onDragEnd={handleDragEnd}
                        >
                            <div className="section-header">
                                <div className="section-drag-handle"><Icons.Grip /></div>
                                <button className="icon-btn" onClick={() => { const newS = [...sections]; newS[sIdx].collapsed = !newS[sIdx].collapsed; setSections(newS); }}>
                                    {section.collapsed ? <Icons.CaretRight /> : <Icons.CaretDown />}
                                </button>
                                <input className="section-title-input" value={section.title} onChange={(e) => { const newS = [...sections]; newS[sIdx].title = e.target.value; setSections(newS); }} onClick={(e) => e.stopPropagation()}/>
                                <button className="icon-btn danger" onClick={() => deleteSection(sIdx)}>
                                    <Icons.Trash />
                                </button>
                            </div>

                            {!section.collapsed && (
                                <>
                                    <ul className="task-list">
                                        {section.tasks.map((task, tIdx) => {
                                            let taskDropClass = '';
                                            if (dropTarget && dropTarget.type === 'TASK' && dropTarget.secIndex === sIdx && dropTarget.taskIndex === tIdx) {
                                                taskDropClass = dropTarget.position === 'top' ? 'drop-target-top' : 'drop-target-bottom';
                                            }
                                            return (
                                                <li key={task.id} className={`task-item ${task.priority ? 'high-priority' : ''} ${taskDropClass}`} 
                                                    onDragOver={(e) => handleDragOver(e, 'TASK', { secIndex: sIdx, taskIndex: tIdx })}
                                                    onDrop={handleDrop}
                                                >
                                                    <div className="task-drag-handle" draggable onDragStart={(e) => handleDragStart(e, 'TASK', { sourceSecIndex: sIdx, itemIndex: tIdx })} onDragEnd={handleDragEnd}>
                                                        <Icons.Dots />
                                                    </div>
                                                    <input type="checkbox" checked={task.completed} onChange={() => toggleTask(sIdx, tIdx)} style={{margin:'0 10px', width:'18px', height:'18px', accentColor: 'var(--primary)'}}/>
                                                    <span className={`task-text ${task.completed ? 'completed' : ''}`}>{task.text}</span>
                                                    <button className={`icon-btn priority-btn ${task.priority ? 'active' : ''}`} onClick={() => togglePriority(sIdx, tIdx)} title="Toggle Priority">
                                                        {task.priority ? <Icons.BoltFill /> : <Icons.Bolt />}
                                                    </button>
                                                    <button className="icon-btn" onClick={() => deleteItem(sIdx, tIdx)}><Icons.X /></button>
                                                </li>
                                            );
                                        })}
                                        {section.tasks.length === 0 && (
                                            <div style={{padding:'30px', textAlign:'center', color:'#9ca3af', fontStyle:'italic'}}>
                                                Drop tasks here
                                            </div>
                                        )}
                                    </ul>
                                    <div className="add-task-row">
                                        <input type="text" placeholder="Add a new task..." onKeyPress={(e) => { if(e.key==='Enter') { addTask(sIdx, e.target.value); e.target.value=''; }}}/>
                                    </div>
                                </>
                            )}
                        </div>
                    );
                })}

                <div style={{textAlign:'center', marginTop: '40px'}}>
                    <button onClick={() => setSections([...sections, {id: Date.now(), title:'New Section', collapsed:false, tasks:[]}])} style={{margin:'0 auto', padding:'10px 20px', fontSize:'1rem'}}>
                        <Icons.Plus /> Add New Section
                    </button>
                </div>
            </div>
        );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script>

</body>
</html>
